//standard libraries
#include <avr/io.h>
#include <util/delay.h>
#include <stddef.h>

//include header
#include "lcd_pcd8544.h"

//global variables
//frame buffer
static uint8_t buffer[NUM_ROWS][NUM_COLUMNS];
//Note :- in terms of displaying characters,
//display can be seen as a 6X14 character matrix
//each character needs 5 columns and 8 rows
//one space is considered to be present after each character
//so, number of columns per character is 6

//ASCII bitmap lookup table
static unsigned char ASCII[][5] = {
  // First 32 characters (0x00-0x19) are ignored. These are
  // non-displayable, control characters.
   {0x00, 0x00, 0x00, 0x00, 0x00} // 0x20
  ,{0x00, 0x00, 0x5f, 0x00, 0x00} // 0x21 !
  ,{0x00, 0x07, 0x00, 0x07, 0x00} // 0x22 "
  ,{0x14, 0x7f, 0x14, 0x7f, 0x14} // 0x23 #
  ,{0x24, 0x2a, 0x7f, 0x2a, 0x12} // 0x24 $
  ,{0x23, 0x13, 0x08, 0x64, 0x62} // 0x25 %
  ,{0x36, 0x49, 0x55, 0x22, 0x50} // 0x26 &
  ,{0x00, 0x05, 0x03, 0x00, 0x00} // 0x27 '
  ,{0x00, 0x1c, 0x22, 0x41, 0x00} // 0x28 (
  ,{0x00, 0x41, 0x22, 0x1c, 0x00} // 0x29 )
  ,{0x14, 0x08, 0x3e, 0x08, 0x14} // 0x2a *
  ,{0x08, 0x08, 0x3e, 0x08, 0x08} // 0x2b +
  ,{0x00, 0x50, 0x30, 0x00, 0x00} // 0x2c ,
  ,{0x08, 0x08, 0x08, 0x08, 0x08} // 0x2d -
  ,{0x00, 0x60, 0x60, 0x00, 0x00} // 0x2e .
  ,{0x20, 0x10, 0x08, 0x04, 0x02} // 0x2f /
  ,{0x3e, 0x51, 0x49, 0x45, 0x3e} // 0x30 0
  ,{0x00, 0x42, 0x7f, 0x40, 0x00} // 0x31 1
  ,{0x42, 0x61, 0x51, 0x49, 0x46} // 0x32 2
  ,{0x21, 0x41, 0x45, 0x4b, 0x31} // 0x33 3
  ,{0x18, 0x14, 0x12, 0x7f, 0x10} // 0x34 4
  ,{0x27, 0x45, 0x45, 0x45, 0x39} // 0x35 5
  ,{0x3c, 0x4a, 0x49, 0x49, 0x30} // 0x36 6
  ,{0x01, 0x71, 0x09, 0x05, 0x03} // 0x37 7
  ,{0x36, 0x49, 0x49, 0x49, 0x36} // 0x38 8
  ,{0x06, 0x49, 0x49, 0x29, 0x1e} // 0x39 9
  ,{0x00, 0x36, 0x36, 0x00, 0x00} // 0x3a :
  ,{0x00, 0x56, 0x36, 0x00, 0x00} // 0x3b ;
  ,{0x08, 0x14, 0x22, 0x41, 0x00} // 0x3c <
  ,{0x14, 0x14, 0x14, 0x14, 0x14} // 0x3d =
  ,{0x00, 0x41, 0x22, 0x14, 0x08} // 0x3e >
  ,{0x02, 0x01, 0x51, 0x09, 0x06} // 0x3f ?
  ,{0x32, 0x49, 0x79, 0x41, 0x3e} // 0x40 @
  ,{0x7e, 0x11, 0x11, 0x11, 0x7e} // 0x41 A
  ,{0x7f, 0x49, 0x49, 0x49, 0x36} // 0x42 B
  ,{0x3e, 0x41, 0x41, 0x41, 0x22} // 0x43 C
  ,{0x7f, 0x41, 0x41, 0x22, 0x1c} // 0x44 D
  ,{0x7f, 0x49, 0x49, 0x49, 0x41} // 0x45 E
  ,{0x7f, 0x09, 0x09, 0x09, 0x01} // 0x46 F
  ,{0x3e, 0x41, 0x49, 0x49, 0x7a} // 0x47 G
  ,{0x7f, 0x08, 0x08, 0x08, 0x7f} // 0x48 H
  ,{0x00, 0x41, 0x7f, 0x41, 0x00} // 0x49 I
  ,{0x20, 0x40, 0x41, 0x3f, 0x01} // 0x4a J
  ,{0x7f, 0x08, 0x14, 0x22, 0x41} // 0x4b K
  ,{0x7f, 0x40, 0x40, 0x40, 0x40} // 0x4c L
  ,{0x7f, 0x02, 0x0c, 0x02, 0x7f} // 0x4d M
  ,{0x7f, 0x04, 0x08, 0x10, 0x7f} // 0x4e N
  ,{0x3e, 0x41, 0x41, 0x41, 0x3e} // 0x4f O
  ,{0x7f, 0x09, 0x09, 0x09, 0x06} // 0x50 P
  ,{0x3e, 0x41, 0x51, 0x21, 0x5e} // 0x51 Q
  ,{0x7f, 0x09, 0x19, 0x29, 0x46} // 0x52 R
  ,{0x46, 0x49, 0x49, 0x49, 0x31} // 0x53 S
  ,{0x01, 0x01, 0x7f, 0x01, 0x01} // 0x54 T
  ,{0x3f, 0x40, 0x40, 0x40, 0x3f} // 0x55 U
  ,{0x1f, 0x20, 0x40, 0x20, 0x1f} // 0x56 V
  ,{0x3f, 0x40, 0x38, 0x40, 0x3f} // 0x57 W
  ,{0x63, 0x14, 0x08, 0x14, 0x63} // 0x58 X
  ,{0x07, 0x08, 0x70, 0x08, 0x07} // 0x59 Y
  ,{0x61, 0x51, 0x49, 0x45, 0x43} // 0x5a Z
  ,{0x00, 0x7f, 0x41, 0x41, 0x00} // 0x5b [
  ,{0x02, 0x04, 0x08, 0x10, 0x20} // 0x5c \
  ,{0x00, 0x41, 0x41, 0x7f, 0x00} // 0x5d ]
  ,{0x00, 0x41, 0x41, 0x7f, 0x00} // 0x5d ]
  ,{0x04, 0x02, 0x01, 0x02, 0x04} // 0x5e ^
  ,{0x40, 0x40, 0x40, 0x40, 0x40} // 0x5f _
  ,{0x00, 0x01, 0x02, 0x04, 0x00} // 0x60 `
  ,{0x20, 0x54, 0x54, 0x54, 0x78} // 0x61 a
  ,{0x7f, 0x48, 0x44, 0x44, 0x38} // 0x62 b
  ,{0x38, 0x44, 0x44, 0x44, 0x20} // 0x63 c
  ,{0x38, 0x44, 0x44, 0x48, 0x7f} // 0x64 d
  ,{0x38, 0x54, 0x54, 0x54, 0x18} // 0x65 e
  ,{0x08, 0x7e, 0x09, 0x01, 0x02} // 0x66 f
  ,{0x0c, 0x52, 0x52, 0x52, 0x3e} // 0x67 g
  ,{0x7f, 0x08, 0x04, 0x04, 0x78} // 0x68 h
  ,{0x00, 0x44, 0x7d, 0x40, 0x00} // 0x69 i
  ,{0x20, 0x40, 0x44, 0x3d, 0x00} // 0x6a j
  ,{0x7f, 0x10, 0x28, 0x44, 0x00} // 0x6b k
  ,{0x00, 0x41, 0x7f, 0x40, 0x00} // 0x6c l
  ,{0x7c, 0x04, 0x18, 0x04, 0x78} // 0x6d m
  ,{0x7c, 0x08, 0x04, 0x04, 0x78} // 0x6e n
  ,{0x38, 0x44, 0x44, 0x44, 0x38} // 0x6f o
  ,{0x7c, 0x14, 0x14, 0x14, 0x08} // 0x70 p
  ,{0x08, 0x14, 0x14, 0x18, 0x7c} // 0x71 q
  ,{0x7c, 0x08, 0x04, 0x04, 0x08} // 0x72 r
  ,{0x48, 0x54, 0x54, 0x54, 0x20} // 0x73 s
  ,{0x04, 0x3f, 0x44, 0x40, 0x20} // 0x74 t
  ,{0x3c, 0x40, 0x40, 0x20, 0x7c} // 0x75 u
  ,{0x1c, 0x20, 0x40, 0x20, 0x1c} // 0x76 v
  ,{0x3c, 0x40, 0x30, 0x40, 0x3c} // 0x77 w
  ,{0x44, 0x28, 0x10, 0x28, 0x44} // 0x78 x
  ,{0x0c, 0x50, 0x50, 0x50, 0x3c} // 0x79 y
  ,{0x44, 0x64, 0x54, 0x4c, 0x44} // 0x7a z
  ,{0x00, 0x08, 0x36, 0x41, 0x00} // 0x7b {
  ,{0x00, 0x00, 0x7f, 0x00, 0x00} // 0x7c |
  ,{0x00, 0x41, 0x36, 0x08, 0x00} // 0x7d }
  ,{0x10, 0x08, 0x08, 0x10, 0x08} // 0x7e ~
  ,{0x78, 0x46, 0x41, 0x46, 0x78} // 0x7f DEL
};


//functions
//write a command byte to lcd
void lcd_write_cmd(unsigned char cmd)
{
	//set D_C pin low (command)
	D_C_PORT &= ~(1<<D_C_LOC);
	//set SCE pin low
	SCE_PORT &= ~(1<<SCE_LOC);
	//write the data to "SPDR" register
	SPDR = cmd;
	//wait until data transmission is done
	while(!(SPSR & (1<<SPIF)));
	//set SCE pin high again
	SCE_PORT |= (1<<SCE_LOC);

	return;
}

//write a data byte to lcd
void lcd_write_data(unsigned char data)
{
	//set D_C pin high (data)
	D_C_PORT |= (1<<D_C_LOC);
	//set SCE pin low
	SCE_PORT &= ~(1<<SCE_LOC);
	//write the data to "SPDR" register
	SPDR = data;
	//wait until data is transmitted
	while(!(SPSR & (1<<SPIF)));
	//set SCE pin high again
	SCE_PORT |= (1<<SCE_LOC);

	return;
}

//lcd initialization sequence
void lcd_init(void)
{
	//configure RST, SCE, D_C, DN and SCLK pins as outputs
	RST_CONFIG |= (1<<RST_LOC);
	SCE_CONFIG |= (1<<SCE_LOC);
	D_C_CONFIG |= (1<<D_C_LOC);
	DN_CONFIG |= (1<<DN_LOC);
	SCLK_CONFIG |= (1<<SCLK_LOC);

	//set SCE and RST pins high (active low pins on lcd)
	SCE_PORT |= (1<<SCE_LOC);
	RST_PORT |= (1<<RST_LOC);

	//use SPI bus to talk to lcd
	//initialize SPI bus
	//enable SPI bus "SPE = 1"
	//MSB of the data word is transmitted first "DORD = 0"
	//enable master SPI mode "MSTR = 1"
	//set clock polarity to low when idle "CPOL = 0"
	//set clock phase to sample at leading edge "CPHA = 0"
	//set SPI clock prescaler to 4 "SPR1 = 0, SPR0 = 0" (drive SPI at max speed)
	SPCR |= ((1<<SPE) | (1<<MSTR));

	//reset the lcd (active low reset)
	RST_PORT &= ~(1<<RST_LOC);
	//delay for 100us
	_delay_us(RST_DELAY);
	//set RST pin high
	RST_PORT |= (1<<RST_LOC);

	//lcd initial config
	//choose extended instruction set
	lcd_write_cmd(0x21);
	//set appropriate bias system for mux rate 1:48
	//BS2 = 0, BS1 = 1, BS0 = 1
	lcd_write_cmd(0x14);
	//set display contrast Vop)
	//0xB1(good @ 3.3V) or 0xBF if display is too dark
	lcd_write_cmd(0x80 | LCD_CONTRAST);
	//set temperature coefficient (0)
	lcd_write_cmd(0x04);
	//switch back to back to basic instruction set
	//also choose vertical addressing
	lcd_write_cmd(0x20);
	//set display configuration to normal mode (D = 1, E = 0)
	lcd_write_cmd(0x0C);

	//initialize frame buffer and clear lcd
	lcd_clear();

	return;
}

//write local frame buffer to lcd memory
void lcd_update(void)
{
	//set X and Y ram address to 0
	lcd_write_cmd(0x80);
	lcd_write_cmd(0x40);

	uint8_t i = 0;
	uint8_t j = 0;
	//copy screen buffer to display ram
	for (i=0; i<NUM_ROWS; i++)
	{
		for(j=0; j<NUM_COLUMNS; j++)
		{
			lcd_write_data(buffer[i][j]);
		}
	}

	return;
}

//clear(turn off) all pixels on the lcd
void lcd_clear(void)
{
	uint8_t i = 0;
	uint8_t j = 0;
	//set entire frame buffer to 0
	for (i=0; i<NUM_ROWS; i++)
	{
		for(j=0; j<NUM_COLUMNS; j++)
		{
			buffer[i][j] = 0;
		}
	}

	lcd_update();

	return;
}

//erase a specific line on the lcd
void lcd_clear_line(uint8_t index)
{
	uint8_t j = 0;
	for(j=0; j<NUM_COLUMNS; j++)
	{
		buffer[index][j] = 0;
	}

	return;
}

//write a character to the specified location in the frame buffer
void lcd_print_char(unsigned char c, uint8_t x_loc, uint8_t y_loc)
{
	if(x_loc>=0 && x_loc<14 && y_loc>=0 && y_loc<6)
	{
		//go to appropriate column
		x_loc = x_loc*6;
		//determine the index where the bitmap of necessary ascii character is stored
		//the first ascii character stored is ' '
		uint8_t ascii_index = c - ' ';
		uint8_t i = 0;

		for(i=0; i<5; i++)
		{
			//rows -> y-coordinate
			//columns -> x-coordinate
			buffer[y_loc][x_loc++] = ASCII[ascii_index][i];
		}

		lcd_update();
	}

	return;
}

//write a string starting at a specified location in the frame buffer
void lcd_print_string(unsigned char* ptr, uint8_t x_loc, uint8_t y_loc)
{
	if(ptr != NULL)
	{
		while(*ptr != '\0')
		{
			lcd_print_char(*(ptr++), x_loc++, y_loc);
			if(x_loc > 13)
			{
				if(y_loc>5)
				{
					//end of screen reached
					break;
				}

				else
				{
					//line wrap the text
					y_loc ++;
					x_loc = 0;
				}
			}
		}
	}

	return;
}
